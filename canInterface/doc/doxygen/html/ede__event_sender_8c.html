<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>comFramework - CAN Interface: ede_eventSender.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">comFramework - CAN Interface<span id="projectnumber">&#160;2.0</span>
   </div>
   <div id="projectbrief">comFramework - CAN Interface - A highly flexible CAN interface for embedded platforms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('ede__event_sender_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ede_eventSender.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="ede__event_sender_8h_source.html">ede_eventSender.h</a>&quot;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &quot;<a class="el" href="ede__external_interfaces_8h_source.html">ede_externalInterfaces.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ede__event_dispatcher_engine_8h_source.html">ede_eventDispatcherEngine.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3ced2f8d5ec2344cfaeadc4c4b986a05"><td class="memItemLeft" align="right" valign="top">typedef struct ede_eventSender_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_sender_8c.html#a3ced2f8d5ec2344cfaeadc4c4b986a05">ede_eventSender_t</a></td></tr>
<tr class="separator:a3ced2f8d5ec2344cfaeadc4c4b986a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a427a4fb0c358294d426691783d816f31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_sender_8c.html#a427a4fb0c358294d426691783d816f31">ede_createSender</a> (<a class="el" href="ede__event_sender_8h.html#aab46fbce36a9ae7c406ff72f2b4ac149">ede_handleSender_t</a> *const pHandleSender, const <a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a> portAry[], unsigned int noPorts, const <a class="el" href="structede__map_sender_ev_handle_to_idx__t.html">ede_mapSenderEvHandleToIdx_t</a> *pMapSenderEvHandleToPortIndex, <a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const pMemPoolSender)</td></tr>
<tr class="separator:a427a4fb0c358294d426691783d816f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3c84ef444f423e5e66db3626323094"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_sender_8c.html#a1c3c84ef444f423e5e66db3626323094">ede_getPortIndex</a> (<a class="el" href="ede__event_sender_8c.html#a3ced2f8d5ec2344cfaeadc4c4b986a05">ede_eventSender_t</a> *const hSender, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a> kindOfEvent, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#ada49b99ab4bcca0e08fdac728087eb65">ede_senderHandleEvent_t</a> senderHandleEvent)</td></tr>
<tr class="separator:a1c3c84ef444f423e5e66db3626323094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab798e6f0c026481f4848e52207136aac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent</a> (<a class="el" href="ede__event_sender_8c.html#a3ced2f8d5ec2344cfaeadc4c4b986a05">ede_eventSender_t</a> *const hSender, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a> kindOfEvent, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#ada49b99ab4bcca0e08fdac728087eb65">ede_senderHandleEvent_t</a> senderHandleEvent, const void *pData, unsigned int sizeOfData)</td></tr>
<tr class="separator:ab798e6f0c026481f4848e52207136aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af784c1f528d120e096159eedfc7a6083"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_sender_8c.html#af784c1f528d120e096159eedfc7a6083">ede_postEventToPort</a> (<a class="el" href="ede__event_sender_8c.html#a3ced2f8d5ec2344cfaeadc4c4b986a05">ede_eventSender_t</a> *const hSender, unsigned int idxPort, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a> kindOfEvent, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#ada49b99ab4bcca0e08fdac728087eb65">ede_senderHandleEvent_t</a> senderHandleEvent, const void *pData, unsigned int sizeOfData)</td></tr>
<tr class="separator:af784c1f528d120e096159eedfc7a6083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a9800ac09da1ab33eafb41a4db3d18"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_sender_8c.html#ac6a9800ac09da1ab33eafb41a4db3d18">ede_allocEventAtPort</a> (<a class="el" href="structede__external_event__t.html">ede_externalEvent_t</a> **const ppEvent, <a class="el" href="ede__event_sender_8c.html#a3ced2f8d5ec2344cfaeadc4c4b986a05">ede_eventSender_t</a> *const hSender, unsigned int idxPort, unsigned int sizeOfData)</td></tr>
<tr class="separator:ac6a9800ac09da1ab33eafb41a4db3d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97795ca01671eed48eedef6188367391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_sender_8c.html#a97795ca01671eed48eedef6188367391">ede_submitEventToPort</a> (<a class="el" href="ede__event_sender_8c.html#a3ced2f8d5ec2344cfaeadc4c4b986a05">ede_eventSender_t</a> *const hSender, unsigned int idxPort)</td></tr>
<tr class="separator:a97795ca01671eed48eedef6188367391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d19cf302860504824ac3749a075d23f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a124b7daa71a5d329213c459f68203f89">ede_atomicUnsignedInt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_sender_8c.html#a0d19cf302860504824ac3749a075d23f">ede_getNoSenderPortBlockedEvents</a> (<a class="el" href="ede__event_sender_8h.html#aab46fbce36a9ae7c406ff72f2b4ac149">ede_handleSender_t</a> hSender, unsigned int idxPort)</td></tr>
<tr class="separator:a0d19cf302860504824ac3749a075d23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Implementation of the event sender. Any number of senders can be created and they can be flexibly connected to an unrelated set of dispatchers. n:m connectivity is supported.</p>
<p >Copyright (C) 2021-2023 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span class="obfuscator">.nosp@m.</span>_Vra<span class="obfuscator">.nosp@m.</span>nken@<span class="obfuscator">.nosp@m.</span>Yaho<span class="obfuscator">.nosp@m.</span>o.de</a>)</p>
<p >This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p >This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p >You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a3ced2f8d5ec2344cfaeadc4c4b986a05" name="a3ced2f8d5ec2344cfaeadc4c4b986a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ced2f8d5ec2344cfaeadc4c4b986a05">&#9670;&nbsp;</a></span>ede_eventSender_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ede_eventSender_t ede_eventSender_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >An event sender object. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a427a4fb0c358294d426691783d816f31" name="a427a4fb0c358294d426691783d816f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427a4fb0c358294d426691783d816f31">&#9670;&nbsp;</a></span>ede_createSender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ede_createSender </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ede__event_sender_8h.html#aab46fbce36a9ae7c406ff72f2b4ac149">ede_handleSender_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandleSender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a>&#160;</td>
          <td class="paramname"><em>portAry</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noPorts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structede__map_sender_ev_handle_to_idx__t.html">ede_mapSenderEvHandleToIdx_t</a> *&#160;</td>
          <td class="paramname"><em>pMapSenderEvHandleToPortIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const&#160;</td>
          <td class="paramname"><em>pMemPoolSender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a sender.<br  />
 A sender has n output ports and it can be connected to n dispatchers. Main API of a sender is <a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent()</a>, which sends an event to the connetced dispatcher input. The exact behavior depends on the element, which is applied to make the connection between the sender's output port and the dispatcher's input port. This will normally be a queue but can be any other connecting operation, which implements the given interface. </p><dl class="section return"><dt>Returns</dt><dd>Get <em>true</em> if the new sender could be created and <em>false</em> otherwise.<br  />
 The function will fail only in case of lack of memory. Since all memory allocation is static and deterministic an appropriate and recommended failure handling concept is to check the return value by assertion only. If the assertion doesn't fire throughout the development and test phase then it won't in the production code. Anyhow, the sender must never be used if this function returns <em>false</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandleSender</td><td>Get the handle of the newly created sender object by reference. This handle is later needed to use the sender. If the function fails then it'll return the special handle <a class="el" href="ede__event_sender_8h.html#a05ef25fbdb9c94224bb049c897fe4cec">EDE_INVALID_SENDER_HANDLE</a> in * <em>pHandleSender</em>.<br  />
</td></tr>
    <tr><td class="paramname">portAry</td><td>All ports of the sender as an array of objects, which implement the given interface. Each port may use the same or another implementation of the interface. Normally, the implementation of the interface will be the tail of the thread-safe queue, see <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html">vsq_threadSafeQueueVariableSize.h</a>, which belongs to this package.<br  />
 The array elements are copied and portAry needs to be valid only during the run time of the constructor. </td></tr>
    <tr><td class="paramname">noPorts</td><td>The number of supported ports and the number of elements in portAry at the same time. </td></tr>
    <tr><td class="paramname">pMapSenderEvHandleToPortIndex</td><td>The (externally implemented) map by reference, which associates the abstract handle of an external event with the output port to use for th given event(by index).<br  />
 If the sender has just one port then no mapping is required and NULL can be passed. All events will go into the only port. Note, a map still matters for a sender with a single port: A map now becomes a Boolean filter, whether or not an event may or can be posted.<br  />
 If only method <a class="el" href="ede__event_sender_8c.html#af784c1f528d120e096159eedfc7a6083">ede_postEventToPort()</a> is going to be used to send an event, i.e., method <a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent()</a> won't be used, then NULL can be passed even for a sender with more than one port. </td></tr>
    <tr><td class="paramname">pMemPoolSender</td><td>A memory pool by reference, which provides the memory needed for construction of the sender object.<br  />
 The memory dealt out by this pool needs to grant write-access to the context that runs the event posting process, i.e., the process, which is going to regularly call ede_sendEvent() for the here created sender object. All other contexts (e.g., dispatchers or other senders) don't need access to the memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The call of this function has to be done in a race condition free environment, prior to entering the multi-tasking phase of the application. Most platforms will offer an initialization task for this purpose. </dd></dl>

</div>
</div>
<a id="a1c3c84ef444f423e5e66db3626323094" name="a1c3c84ef444f423e5e66db3626323094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3c84ef444f423e5e66db3626323094">&#9670;&nbsp;</a></span>ede_getPortIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ede_getPortIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ede__event_sender_8c.html#a3ced2f8d5ec2344cfaeadc4c4b986a05">ede_eventSender_t</a> *const&#160;</td>
          <td class="paramname"><em>hSender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a>&#160;</td>
          <td class="paramname"><em>kindOfEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#ada49b99ab4bcca0e08fdac728087eb65">ede_senderHandleEvent_t</a>&#160;</td>
          <td class="paramname"><em>senderHandleEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find the port of a sender object, which is associated with an event about to be posted. The association is made using the map object, which has been provided in the constructor of the sender. (At the same time the mapping, which is implicitly used by <a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent()</a>.) The explicit call of this function may be useful if the two-step method for posting an event is applied, i.e., using <a class="el" href="ede__event_sender_8c.html#ac6a9800ac09da1ab33eafb41a4db3d18">ede_allocEventAtPort()</a> and <a class="el" href="ede__event_sender_8c.html#a97795ca01671eed48eedef6188367391">ede_submitEventToPort()</a> instead of <a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent()</a> or <a class="el" href="ede__event_sender_8c.html#af784c1f528d120e096159eedfc7a6083">ede_postEventToPort()</a>. </p><dl class="section return"><dt>Returns</dt><dd>The port of the sender object, which is associated with the given event, is returned by zero based index. The function returns UINT_MAX if not suitable port could be identified. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSender</td><td>The sender object to use. Has been created before by <a class="el" href="ede__event_sender_8c.html#a427a4fb0c358294d426691783d816f31">ede_createSender()</a>. </td></tr>
    <tr><td class="paramname">kindOfEvent</td><td>The kind of event. It is an enumeration, which is meaningless to the sender or dispatcher object. Which values are passed is entirely in the scope of the integration code, which defines both, the event reporting interrupts and the client code, which eventually evaluates the transmitted events. In the case of CAN communication, this will, e.g., be the CAN message reception event. </td></tr>
    <tr><td class="paramname">senderHandleEvent</td><td>The event's handle as used (and issued) by the external integration code. In the case of CAN communication, this will, e.g., be the operating system's handle of a registered CAN message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab798e6f0c026481f4848e52207136aac" name="ab798e6f0c026481f4848e52207136aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab798e6f0c026481f4848e52207136aac">&#9670;&nbsp;</a></span>ede_postEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ede_postEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ede__event_sender_8c.html#a3ced2f8d5ec2344cfaeadc4c4b986a05">ede_eventSender_t</a> *const&#160;</td>
          <td class="paramname"><em>hSender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a>&#160;</td>
          <td class="paramname"><em>kindOfEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#ada49b99ab4bcca0e08fdac728087eb65">ede_senderHandleEvent_t</a>&#160;</td>
          <td class="paramname"><em>senderHandleEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sizeOfData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >An event is posted. It is sent via the associated sender's port.<br  />
 This function is invoked by the integration code. In the case of CAN communication, the call is typically used from within a CAN interrupt handler. The posted event normally is a frame reception event or a frame send acknowledge event. Generally, the kind of postable events depends on the platform and the integration.<br  />
 The event is posted to the port, which is named by the map that had been agreed on during construction of the sender. This indirect port selection has been defined in order to allow the external intergration code to specify the connectivity still at run time. As an example, and for CAN communication, the external code could decide for each particular CAN message, whether it is processed by the QM code or by the safety code. If this flexibility is not required then the other API <a class="el" href="ede__event_sender_8c.html#af784c1f528d120e096159eedfc7a6083">ede_postEventToPort()</a> can be used.<br  />
 The meaning of an event is widely transparent to sender and dispatcher. The event is identified by two values of basic integral data type. The first value is the "kind of
event" and this will be an enumeration. The only constraint sender and dispatcher put on this value are a few numeric values, which are reserved for internal purpose; see <a class="el" href="ede__event_dispatcher_engine_8h.html#a47c207ede4c03db1627850da02b67e68">EDE_EV_KIND_LAST</a> for details. The second value is a handle or ID of the event. Use and meaning of this value are unconstrained and fully transparant to sender and dispatcher. Having two value to identify an event means that each kind of event has its own handle space; this has been decide to support heterogenous events. </p><dl class="section return"><dt>Returns</dt><dd><em>true</em>, if function succeeded, else <em>false</em>. For most imaginable implementations of the port interface, it'll be possible that the port is currently not able to process a new event, e.g., because of a queue full state. In this case, the event is entirely ignored (besides reporting the port-blocked event). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSender</td><td>The sender object to use. Has been created before by <a class="el" href="ede__event_sender_8c.html#a427a4fb0c358294d426691783d816f31">ede_createSender()</a>. </td></tr>
    <tr><td class="paramname">kindOfEvent</td><td>The kind of event. It is an enumeration, which is meaningless to the sender or dispatcher object. Which values are passed is entirely in the scope of the integration code, which defines both, the event reporting interrupts and the client code, which eventually evaluates the transmitted events. In the case of CAN communication, this will, e.g., be the CAN message reception event. </td></tr>
    <tr><td class="paramname">senderHandleEvent</td><td>The event's handle as used (and issued) by the external integration code. In the case of CAN communication, this will , e.g., be the operating system's handle of a registered CAN message. </td></tr>
    <tr><td class="paramname">pData</td><td>A pointer to some event data, which is meaningless to the sender and dispatcher object. Typically used to convey CAN message content bytes in case of a reception event, but can be anything else. May be NULL if <em>sizeOfData</em> is zero, too. </td></tr>
    <tr><td class="paramname">sizeOfData</td><td>The number of data bytes, i.e., the number of bytes, <em>pData</em> points to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Posting an event to a particular port of the sender is not reentrant. If event sources running in different CPU contexts are posting to one and the same sender port then the integration code needs to implement mutual exclusion. All of these event sources need to be serialized with respect to event posting.<br  />
 In practice, concurrent event sources that require mutual exclusion will likely occur if the events are reported by different interrupts; different interrupts have different priorities on most existing systems and interrupts of higher priority are normally allowed to preempt those of lower priority. In this situation, a reasonable alternative to explicit mutual exclusion code is an architecture using another interconnected pair of sender and and dispatcher port for each interrupt. </dd></dl>

</div>
</div>
<a id="af784c1f528d120e096159eedfc7a6083" name="af784c1f528d120e096159eedfc7a6083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af784c1f528d120e096159eedfc7a6083">&#9670;&nbsp;</a></span>ede_postEventToPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ede_postEventToPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ede__event_sender_8c.html#a3ced2f8d5ec2344cfaeadc4c4b986a05">ede_eventSender_t</a> *const&#160;</td>
          <td class="paramname"><em>hSender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a>&#160;</td>
          <td class="paramname"><em>kindOfEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#ada49b99ab4bcca0e08fdac728087eb65">ede_senderHandleEvent_t</a>&#160;</td>
          <td class="paramname"><em>senderHandleEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sizeOfData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >An event is posted. It is sent via the explicitly stated sender's port.<br  />
 See other API <a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent()</a> for more details. The only difference between both functions is the way, the port to use is selected. </p><dl class="section return"><dt>Returns</dt><dd><em>true</em>, if function succeeded, else <em>false</em>. The event has been sent and will be delivered to the dispatcher only if the function returns <em>true</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSender</td><td>The sender object to use. Has been created before by <a class="el" href="ede__event_sender_8c.html#a427a4fb0c358294d426691783d816f31">ede_createSender()</a>. </td></tr>
    <tr><td class="paramname">idxPort</td><td>The port to be applied for the event by zero based index. The specified number must not be greater or equal to argument <em>noPorts</em> of the constructor call, which yielded <em>hSender</em>. </td></tr>
    <tr><td class="paramname">kindOfEvent</td><td>The kind of event. It is an enumeration, which is meaningless to connector element and dispatcher engine. </td></tr>
    <tr><td class="paramname">senderHandleEvent</td><td>The event's handle as used (and issued) by the external integration code system. In the case of CAN communication, this will , e.g., be the operating system's handle of a registered CAN message. </td></tr>
    <tr><td class="paramname">pData</td><td>A pointer to some event data. It is delivered to the dispatcher as part of the event. </td></tr>
    <tr><td class="paramname">sizeOfData</td><td>The number of data bytes, i.e., the number of bytes, <em>pData</em> points to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>All remarks made for <a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent()</a> hold for this function, too. </dd></dl>

</div>
</div>
<a id="ac6a9800ac09da1ab33eafb41a4db3d18" name="ac6a9800ac09da1ab33eafb41a4db3d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a9800ac09da1ab33eafb41a4db3d18">&#9670;&nbsp;</a></span>ede_allocEventAtPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ede_allocEventAtPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structede__external_event__t.html">ede_externalEvent_t</a> **const&#160;</td>
          <td class="paramname"><em>ppEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_sender_8c.html#a3ced2f8d5ec2344cfaeadc4c4b986a05">ede_eventSender_t</a> *const&#160;</td>
          <td class="paramname"><em>hSender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sizeOfData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Posting an event can be done in two steps: First the allocation or reservation of the needed memory space and later, after filling the memory appropriately, the submission of the event. The two-step approach is an alternative to the use of either <a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent()</a> or <a class="el" href="ede__event_sender_8c.html#af784c1f528d120e096159eedfc7a6083">ede_postEventToPort()</a>, which allows the implementation of zero-copy interfaces in some situations.<br  />
 This function implements the reservation of the memory space. </p><dl class="section return"><dt>Returns</dt><dd>The address, where to put the event's payload data, is returned. Normally, this will just be the address of the event's field <em>dataAry</em> but it may be another, port decided address. (See the sender port's field <em>requiresDataByReference</em> for details.)<br  />
 The function returns NULL if the port can't provide the needed memory. Almost always, this will be due to a temporary busy or queue-full state of the port. No event can currently be posted and the function call has no effect besides counting the failure in the port object. In particular, <a class="el" href="ede__event_sender_8c.html#a97795ca01671eed48eedef6188367391">ede_submitEventToPort()</a> must not be called in this case.<br  />
 See field <em>dataAry</em> of type <em><a class="el" href="structede__external_event__t.html">ede_externalEvent_t</a></em> for details about the alignment of the returned pointer. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ppEvent</td><td>If the function doesn't return NULL then a still empty, not yet submitted event object is returned by reference in * <em>ppEvent</em>. The ownership of the event object is now at the caller. The caller has any time to fill the event object until he submits it.<br  />
<ul>
<li><em>ppEvent</em> is undefined if the function returns NULL. </li>
</ul>
</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hSender</td><td>The sender object to use. Has been created before by <a class="el" href="ede__event_sender_8c.html#a427a4fb0c358294d426691783d816f31">ede_createSender()</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">idxPort</td><td>The port by zero based index, which the event is going to be posted to. This port will provide the memory space for the returned event object.<br  />
 The specified number must not be greater or equal to argument <em>noPorts</em> of the constructor call, which yielded <em>hSender</em>.<br  />
 Note, if applicable, the required port index could be figured out using <a class="el" href="ede__event_sender_8c.html#a1c3c84ef444f423e5e66db3626323094">ede_getPortIndex()</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sizeOfData</td><td>The number of payload data bytes, which the returned event needs to have at least. This number of Byte can be safely written to where the function return value points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Using the pair of <a class="el" href="ede__event_sender_8c.html#ac6a9800ac09da1ab33eafb41a4db3d18">ede_allocEventAtPort()</a> and <a class="el" href="ede__event_sender_8c.html#a97795ca01671eed48eedef6188367391">ede_submitEventToPort()</a> has race conditions with using <a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent()</a> and <a class="el" href="ede__event_sender_8c.html#af784c1f528d120e096159eedfc7a6083">ede_postEventToPort()</a>. The three ways of doing can be used alternatingly but not in an overlapping or concurrent way. In particular, if <a class="el" href="ede__event_sender_8c.html#ac6a9800ac09da1ab33eafb41a4db3d18">ede_allocEventAtPort()</a> succeeded to return an event, then <a class="el" href="ede__event_sender_8c.html#a97795ca01671eed48eedef6188367391">ede_submitEventToPort()</a> needs to be called for that event prior to the next use of either <a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent()</a> or <a class="el" href="ede__event_sender_8c.html#af784c1f528d120e096159eedfc7a6083">ede_postEventToPort()</a>. </dd></dl>

</div>
</div>
<a id="a97795ca01671eed48eedef6188367391" name="a97795ca01671eed48eedef6188367391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97795ca01671eed48eedef6188367391">&#9670;&nbsp;</a></span>ede_submitEventToPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ede_submitEventToPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ede__event_sender_8c.html#a3ced2f8d5ec2344cfaeadc4c4b986a05">ede_eventSender_t</a> *const&#160;</td>
          <td class="paramname"><em>hSender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Posting an event using the two-step approach: Submit the finalized event. See <a class="el" href="ede__event_sender_8c.html#ac6a9800ac09da1ab33eafb41a4db3d18">ede_allocEventAtPort()</a> for more details.<br  />
 Caution: The ownership of the event ends with entry into this function. The event object and none of its fields must be touched any more. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSender</td><td>The sender object to use. Has been created before by <a class="el" href="ede__event_sender_8c.html#a427a4fb0c358294d426691783d816f31">ede_createSender()</a>. </td></tr>
    <tr><td class="paramname">idxPort</td><td>The port by zero based index, which the event is submitted to.<br  />
 Caution: This needs to be the same port as specified in the earlier call of <a class="el" href="ede__event_sender_8c.html#ac6a9800ac09da1ab33eafb41a4db3d18">ede_allocEventAtPort()</a>, when getting the event object. It would be disastrous to submit an event to another port. It would result in unpredictable behavior reaching from memory leak till corrupted memories. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function implicitly operates on the very object, which had been got with the last recent call of <a class="el" href="ede__event_sender_8c.html#ac6a9800ac09da1ab33eafb41a4db3d18">ede_allocEventAtPort()</a>, which had been made for port <em>idxPort</em>. </dd></dl>

</div>
</div>
<a id="a0d19cf302860504824ac3749a075d23f" name="a0d19cf302860504824ac3749a075d23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d19cf302860504824ac3749a075d23f">&#9670;&nbsp;</a></span>ede_getNoSenderPortBlockedEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a124b7daa71a5d329213c459f68203f89">ede_atomicUnsignedInt_t</a> ede_getNoSenderPortBlockedEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ede__event_sender_8h.html#aab46fbce36a9ae7c406ff72f2b4ac149">ede_handleSender_t</a>&#160;</td>
          <td class="paramname"><em>hSender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the number of recorded port-blocked events, i.e. the number of lost events due to an currently unavailable port, e.g., because of an overfull queue. </p><dl class="section return"><dt>Returns</dt><dd>Get the number, which should should rise very slowly or not at all in case of a well designed implementation of the port interface. The counter for port-blocked events wraps at its implementation range. Therefore, the client code can easliy check for an allowed maximum loss rate by regularly evaluating the delta/increment of the returned function value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSender</td><td>The sender object, which the query is made for. </td></tr>
    <tr><td class="paramname">idxPort</td><td>The port, which the query is made for, by zero based index. The specified number must not be greater or equal to argument <em>noPorts</em> of the constructor call, which yielded <em>hSender</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function can be called at any time from any context, which has read access to the memory, which had been used for construction of the sender object; see argument <em>pMemPoolSender</em> of <a class="el" href="ede__event_sender_8c.html#a427a4fb0c358294d426691783d816f31">ede_createSender()</a> for details. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_081dba3b7b2444bc5b95b682ee9f194a.html">eventDispatcher</a></li><li class="navelem"><a class="el" href="ede__event_sender_8c.html">ede_eventSender.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
